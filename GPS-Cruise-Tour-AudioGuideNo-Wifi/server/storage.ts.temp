        name: 'Esperienza di Corso di Cucina Thailandese',
        narration: 'Padroneggia l\'arte della cucina thailandese in questo corso di cucina pratico. Impara a preparare piatti classici usando ingredienti locali freschi e tecniche tradizionali.',
        description: 'Autentico corso di cucina thailandese con tour del mercato',
        detailedDescription: 'Questo corso di cucina thailandese immersivo offre molto più che ricette - è un\'esperienza culturale che rivela il cuore della cucina thailandese. Inizia con un tour guidato di un mercato locale dove il tuo istruttore spiega ingredienti esotici come galangal, foglie di lime kaffir, varietà di basilico thailandese e gradi di salsa di pesce. Impara a selezionare i prodotti più freschi e comprendi l\'importanza di ogni ingrediente. Torna in una cucina thailandese tradizionale o padiglione di cucina all\'aperto per preparare 4-5 piatti classici come zuppa tom yum, pad thai, curry verde, som tam (insalata di papaya) e riso appiccicoso al mango. Padroneggia tecniche essenziali come pestare la pasta di curry in un mortaio, raggiungere il perfetto equilibrio di dolce, acido, salato e piccante e corretta gestione del wok. Le dimensioni intime delle classi garantiscono attenzione personalizzata. Goditi le tue creazioni a pranzo o cena e porta a casa schede ricette e un certificato. Modifiche vegetariane e dietetiche disponibili.'
      },
      ko: {
        name: '태국 요리 수업 체험',
        narration: '이 실습 요리 수업에서 태국 요리의 예술을 마스터하세요. 신선한 지역 재료와 전통 기술을 사용하여 고전 요리를 준비하는 방법을 배우세요.',
        description: '시장 투어가 포함된 정통 태국 요리 수업',
        detailedDescription: '이 몰입형 태국 요리 수업은 레시피 이상을 제공합니다 - 태국 요리의 핵심을 드러내는 문화 경험입니다. 강사가 갈랑갈, 카피르 라임 잎, 태국 바질 품종, 피시 소스 등급과 같은 이국적인 재료를 설명하는 지역 시장의 가이드 투어로 시작합니다. 가장 신선한 농산물을 선택하는 방법을 배우고 각 재료의 중요성을 이해하세요. 전통적인 태국 주방이나 야외 요리 파빌리온으로 돌아와 톰얌 수프, 팟타이, 그린 커리, 솜탐(파파야 샐러드), 망고 스티키 라이스와 같은 4-5가지 고전 요리를 준비합니다. 절구에서 커리 페이스트를 찧는 것, 단맛, 신맛, 짠맛, 매운맛의 완벽한 균형을 이루는 것, 적절한 웍 다루기와 같은 필수 기술을 마스터하세요. 소규모 수업 규모는 개인별 관심을 보장합니다. 점심이나 저녁으로 여러분의 창작물을 즐기고, 레시피 카드와 수료증을 가져가세요. 채식 및 식이 조절이 가능합니다.'
      }
    }
  }
];

export class MemStorage implements IStorage {
  async getCities(): Promise<City[]> {
    return CITIES;
  }

  async getCity(id: string): Promise<City | undefined> {
    return CITIES.find(city => city.id === id);
  }

  async getLandmarks(cityId?: string): Promise<Landmark[]> {
    if (cityId) {
      return LANDMARKS.filter(landmark => landmark.cityId === cityId);
    }
    return LANDMARKS;
  }

  async getLandmark(id: string): Promise<Landmark | undefined> {
    return LANDMARKS.find(landmark => landmark.id === id);
  }

  // Visited landmarks methods - using database
  async markLandmarkVisited(landmarkId: string, sessionId?: string): Promise<VisitedLandmark> {
    // Use ON CONFLICT DO NOTHING to prevent duplicate visits
    const [visited] = await db
      .insert(visitedLandmarks)
      .values({ landmarkId, sessionId })
      .onConflictDoNothing()
      .returning();
    
    // If no row returned (duplicate), fetch the existing one
    if (!visited) {
      const conditions = sessionId 
        ? and(eq(visitedLandmarks.landmarkId, landmarkId), eq(visitedLandmarks.sessionId, sessionId))
        : eq(visitedLandmarks.landmarkId, landmarkId);
      
      const [existing] = await db
        .select()
        .from(visitedLandmarks)
        .where(conditions!);
      return existing;
    }
    
    return visited;
  }

  async getVisitedLandmarks(sessionId?: string): Promise<VisitedLandmark[]> {
    if (sessionId) {
      return await db
        .select()
        .from(visitedLandmarks)
        .where(eq(visitedLandmarks.sessionId, sessionId));
    }
    return await db.select().from(visitedLandmarks);
  }

  async isLandmarkVisited(landmarkId: string, sessionId?: string): Promise<boolean> {
    const conditions = sessionId
      ? and(eq(visitedLandmarks.landmarkId, landmarkId), eq(visitedLandmarks.sessionId, sessionId))
      : eq(visitedLandmarks.landmarkId, landmarkId);
    
    const results = await db
      .select()
      .from(visitedLandmarks)
      .where(conditions!);
    
    return results.length > 0;
  }

  async getVisitedCount(sessionId?: string): Promise<number> {
    if (sessionId) {
      const result = await db
        .select({ count: count() })
        .from(visitedLandmarks)
        .where(eq(visitedLandmarks.sessionId, sessionId));
      return result[0]?.count || 0;
    }
    
    const result = await db
      .select({ count: count() })
      .from(visitedLandmarks);
    return result[0]?.count || 0;
  }
}

export const storage = new MemStorage();
